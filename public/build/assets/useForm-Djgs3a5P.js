import{W as a,Z as h,X as y,_ as j}from"./app-KVSHziSA.js";function T(u,d){const c=typeof u=="string"?u:null,f=(typeof u=="string"?d:u)??{},S=typeof f=="function"?f():f,i=c?a.restore(c):null;let l=h(S),n=null,g=null,b=e=>e;const p=y({...i?i.data:S,isDirty:!1,errors:i?i.errors:{},hasErrors:!1,progress:null,wasSuccessful:!1,recentlySuccessful:!1,processing:!1,setStore(e,s=void 0){p.update(t=>Object.assign(t,typeof e=="string"?{[e]:s}:e))},data(){return Object.keys(S).reduce((e,s)=>(e[s]=this[s],e),{})},transform(e){return b=e,this},defaults(e,s){return l=typeof e>"u"?h(this.data()):Object.assign(h(l),typeof e=="string"?{[e]:s}:e),this},reset(...e){const s=h(l);return e.length===0?this.setStore(s):this.setStore(Object.keys(s).filter(t=>e.includes(t)).reduce((t,o)=>(t[o]=s[o],t),{})),this},setError(e,s){return this.setStore("errors",{...this.errors,...typeof e=="string"?{[e]:s}:e}),this},clearErrors(...e){return this.setStore("errors",Object.keys(this.errors).reduce((s,t)=>({...s,...e.length>0&&!e.includes(t)?{[t]:this.errors[t]}:{}}),{})),this},submit(e,s,t={}){const o=b(this.data()),E={...t,onCancelToken:r=>{if(n=r,t.onCancelToken)return t.onCancelToken(r)},onBefore:r=>{if(this.setStore("wasSuccessful",!1),this.setStore("recentlySuccessful",!1),g&&clearTimeout(g),t.onBefore)return t.onBefore(r)},onStart:r=>{if(this.setStore("processing",!0),t.onStart)return t.onStart(r)},onProgress:r=>{if(this.setStore("progress",r),t.onProgress)return t.onProgress(r)},onSuccess:async r=>{if(this.setStore("processing",!1),this.setStore("progress",null),this.clearErrors(),this.setStore("wasSuccessful",!0),this.setStore("recentlySuccessful",!0),g=setTimeout(()=>this.setStore("recentlySuccessful",!1),2e3),t.onSuccess)return t.onSuccess(r)},onError:r=>{if(this.setStore("processing",!1),this.setStore("progress",null),this.clearErrors().setError(r),t.onError)return t.onError(r)},onCancel:()=>{if(this.setStore("processing",!1),this.setStore("progress",null),t.onCancel)return t.onCancel()},onFinish:r=>{if(this.setStore("processing",!1),this.setStore("progress",null),n=null,t.onFinish)return t.onFinish(r)}};e==="delete"?a.delete(s,{...E,data:o}):a[e](s,o,E)},get(e,s){this.submit("get",e,s)},post(e,s){this.submit("post",e,s)},put(e,s){this.submit("put",e,s)},patch(e,s){this.submit("patch",e,s)},delete(e,s){this.submit("delete",e,s)},cancel(){n==null||n.cancel()}});return p.subscribe(e=>{e.isDirty===j(e.data(),l)&&e.setStore("isDirty",!e.isDirty);const s=Object.keys(e.errors).length>0;e.hasErrors!==s&&e.setStore("hasErrors",!e.hasErrors),c&&a.remember({data:e.data(),errors:e.errors},c)}),p}export{T as u};
